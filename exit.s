
# 目的: 退出并向 linux 内核返回一个状态码的简单程序
#
# 输入: 无
#
# 输出: 返回一个状态码, 在运行程序后可通过输入 echo $? 来读取状态码
#
# 变量: 
# %eax 保存系统调用号
# %ebx 保存返回状态
#
# 在汇编程序中, 任何以小数点符号(.) 开始的指令都不会被直接翻译为机器指令,
# 而是属于汇编程序本身的指令, 由于是汇编程序处理, 实际上并不会由计算机运行,
# 因此称为汇编指令或伪操作.

.section .data # 数据段, 数据段中要列出程序数据所需的所有内存存储空间

.section .text # 文本段(代码段), 存放程序指令

.global _start  # _start 是个符号, 将在汇编或链接过程中被其他内容替换, 符号用
				# 来标记程序和数据的位置, 所以可以用名字而非内存位置编号指代;

			    # .global 表示汇编程序不应在汇编之后废弃此符号, 因为链接阶段
				# 还要使用, _start 是个特殊符号, 总是用 .global 标记, 因为
				# _start 标记了程序开始的位置, 如果不标记, 计算机加载程序时就
				# 不知从何处开始运行程序.

_start: # 定义 _start 标签的值, 标签定义一个符号的值; 当汇编程序对程序进行
		# 汇编时, 必须为每个数值和每条指令分配地址; 标签告诉汇编程序以该符号
		# 的值作为下一条指令或下一个数据元素的位置; 如果数据或指令的实际物理
		# 位置更改, 就无需重写其引用, 因此符号会自动获取新值.

movl $1, %eax # 用于退出程序的 linux 内核命令(系统调用)
			  # movl 源操作数 目的操作数
              # 操作数可以是数字, 内存位置引用或寄存器
			  # 从一个内存位置复制一个字大小的数据到另一个内存位置

movl $1, %ebx # 返回状态码给操作系统, 改变这个数字, 则返回到 echo $? 的值不同

int $0x80 # 将唤醒内核, 以运行退出命令

# linux 中命令行 echo $? 返回上条命令执行的结果(返回值) 
# 汇编程序 - 将汇编代码转换为机器指令(as 是Linux上运行汇编程序的命令)
# exit.o 称为目标文件, 是用机器语言写成的代码
#> as exit.s -o exit.o
# 目标文件的内容通常不完全放在一处, 对于大型程序, 将每个源文件转换为目标文件后,
# 使用链接器程序把多个目标文件合而为一，并且向其中添加信息, 以使内核知道如何加
# 载和运行该目标文件. (ld 是运行链接器的命令)
#> ld exit.o -o exit
# 运行 ./exit 没有任何输出, 因为该程序的功能只是退出, 在运行后执行 echo $?
# 输出 0, 这是因为每个程序退出时都会返回给 linux 一个退出状态码, 告诉系统一切
# 运行是否正常.

# 注意: 对于源文件的任何修改, 都要重新汇编和链接



					
			
